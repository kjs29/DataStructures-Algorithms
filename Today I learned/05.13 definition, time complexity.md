# DataStructures & Algorithms, Time Complexity

What is DataStructures & Algorithms(DSA)?

- Data: Collection of facts.

- Data Structures: Specific ways to organize or store data in a computer. They are 

- Algorithms: Specific ways to get what we want efficiently. They perform on data structures such as sorting, searching, or transforming data.

# How we do measure algorithm's efficiency?

Time Complexity

Space Complexity

# What is Time Complexity?

Time Complexity gives us an estimate of the worst-case scenario in terms of how the runtime grows with the size of the input.

# How do we calculate the time Complexity of this?

```js
for (let i = 0; i < 4; i++) {
    // statement
}
```

This `for` loop operates as long as the condition is `true`.

| iteration(k) | value of i | condition (true or false) | Statement |
|---|---|---|---|
| 1 | 0 | true | statement is executed |
|2| 1 | true | statement is executed |
|3| 2 | true | statement is executed |
|4| 3 | true | statement is executed |
|5| 4 | false | statement is not executed |

When `i` = 0, statement is executed

When `i` = 1, statement is executed

When `i` = 2, statement is executed

When `i` = 3, statement is executed

When `i` = 4, statement is not executed.

When the condition is `i < 4`, this for loop iterated 4 times.

We can say that time complexity of this for loop is `O(4)` and it is `O(1)` because any contant value becomes 1.

But instead of `i < 4`, if it is `i < n`, then the Big-O notation will be `O(n)`.

#### Let's look at this example.

```js
function arrayMax(arr) {
    let currentMax = arr[0];        

    for (let i = 1; i < arr.length; i++) {
        if (currentMax < arr[i]) {      
            currentMax = arr[i];        
        }
    }

    return currentMax;
}
```

We can see that inside `for` loop, we see `if` clause.

```js
if (currentMax < arr[i]) {      
    currentMax = arr[i];        
}
```

For simplicity, we can assume that `currentMax < arr[i]` does 1 calculation,

and if the condition is true, `currentMax = arr[i]` does 1 calculation as well.

In the worst case scenario, the condition is always true every single iteration.

So we know that now

```js
if (currentMax < arr[i]) {      
    currentMax = arr[i];        
}
```

this has 2 calculation.

Now let's take a look at how many times `for loop` iterates over.

```js
for (let i = 1; i < arr.length; i++) {

}
```

Since we don't know `arr.length`, let's assume that `arr.length` is `n`.

Then we iterates n - 1 times because i is already 1.

When `arr.length` = 5, it iterates 4 times.

When `arr.length` = 10, it iterates 9 times.

When `arr.length` = n, it iterates n - 1 times.

Putting it all together, it calculates 2 times each iteration, and it iterates n - 1 times.

That is `2  * (n - 1)` calculations.

And we add 1 because `let currentMax = arr[0];` does 1 calculation.

```js
function arrayMax(arr) {
    let currentMax = arr[0];                    // 1

    for (let i = 1; i < arr.length; i++) {      // (n - 1) 

        if (currentMax < arr[i]) {              // 1
            currentMax = arr[i];                // 1
        }
    }

    return currentMax;
}
```

```
1 + 2 * (n - 1) = 2n - 1
```

Because we ignore constants, the time complexity is `O(n)`.

Here is another example.

```js
for (let i = 1; i < n; i*=2) {
    // statement
}
```

| iteration(k) | value of i | condition (true or false) | Statement |
|---|---|---|---|
| 1 | 2^0 = 1 | (1 < n) is true | statement is executed |
| 2 | 2^1 = 2 | (2 < n) is true | statement is executed |
| 3 | 2^2 = 4 | (4 < n) is true | statement is executed |
| 4 | 2^3 = 8 | (8 < n) is true | statement is executed |
| 5 | 2^4 = 16 | (16 < n) is true | statement is executed |
|  | ... | ... | ... |
| k | 2^(k-1) | (2^(k-1) < n) is true | statement is executed |
| k+1 | 2^k | (2^k < n) is false | statement is not executed |

In each iteration, the value of `i` grows

2^0 = 1

2^0 * 2 = 2

2^1 * 2 = 4

2^2 * 2 = 8

2^3 * 2 = 16

`k` represents the number of iterations a loop performs.

Now we have to find out what the value of `i` will be based on k times of iteration. Because we are interested in if `i` value will be true or false on k times of iteration.

Now let's find a formula.

When k = 1, 

`i = 2^0 = 2^(k-1) = 1`

When k = 2, 

`i = 2^1 = 2^(k-1) = 2`

When k = 3, 

`i = 2^2 = 2^(k-1) = 4`

When k = 4, 

`i = 2^3 = 2^(k-1) = 8`

That means that for k times of iteration, the `i` value will be `2^(k-1)`

When `(i < n)` is false, the for loop stops. So we can say that when `(i == n)`, it also stops.

Since the `i` value is `2^(k-1)`,

`2^(k-1) = n`

`k - 1 = log2(n)`

`k = log2(n) + 1`. We also care about the highest order term, so it is just `log(n)`.

So the answer is `O(log(n))`
